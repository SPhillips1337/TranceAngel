<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Trance - Python Brain + Tone.js</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js" integrity="sha512-jduERlz7En1IUZR54bqzpNI64AbffZWR//KJgF71SJ8D8/liKFZ+s1RxmUmB+bhCnIfzebdZsULwOrbVB5f3nQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://unpkg.com/@tonejs/midi"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <div id="code-log"></div>
    <div id="ui-container">
        <h1>Generative Trance</h1>
        <p id="state-display">State: Stopped</p>
        <button id="start-stop-btn">START</button>

        <div id="instrument-toggles">
            <button class="toggle-btn active" data-inst="kick">KICK</button>
            <button class="toggle-btn active" data-inst="bass">BASS</button>
            <button class="toggle-btn active" data-inst="lead">SYNTH</button>
            <button class="toggle-btn active" data-inst="chords">CHORDS</button>
            <button class="toggle-btn active" data-inst="piano">PIANO</button>
            <button class="toggle-btn active" data-inst="pads">PADS</button>
            <button class="toggle-btn active" data-inst="arp">ARP</button>
        </div>

        <div id="controls">
            <div class="control-group">
                <label>Acid Cutoff</label>
                <input type="range" id="cutoff-slider" min="400" max="9000" value="1000">
            </div>
            <div class="control-group">
                <label>SuperSaw Width</label>
                <input type="range" id="width-slider" min="0" max="100" value="20">
            </div>
            <div class="control-group">
                <label>Reverb Mix</label>
                <input type="range" id="reverb-slider" min="0" max="100" value="30">
            </div>
            <div class="control-group">
                <label>MIDI Out</label>
                <select id="midi-out-select">
                    <option value="none">None (Internal Only)</option>
                </select>
            </div>
            <div class="control-group">
                <label>MIDI In</label>
                <select id="midi-in-select">
                    <option value="none">None</option>
                </select>
            </div>
            <div class="control-group">
                <label>Melodic Seed</label>
                <select id="seed-select">
                    <option value="none">None (Generative)</option>
                    <option value="uplifting_arp">Uplifting Arp</option>
                    <option value="rolling_bassline">Rolling Bassline</option>
                    <option value="acid_sequence">Acid Sequence</option>
                </select>
            </div>
            <div class="control-group">
                <label>Mutation</label>
                <input type="range" id="mutation-slider" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>LFO Rate</label>
                <input type="range" id="lfo-rate-slider" min="0.1" max="10" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>LFO Depth</label>
                <input type="range" id="lfo-depth-slider" min="0" max="1" step="0.01" value="0">
            </div>
            <div class="control-group">
                <label>Distortion</label>
                <input type="range" id="distortion-slider" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>Chorus</label>
                <input type="range" id="chorus-slider" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>Reactive Mode</label>
                <input type="checkbox" id="reactive-checkbox">
            </div>
            <div class="control-group">
                <label>Arp Mode</label>
                <select id="arp-mode-select">
                    <option value="UpDown">Up-Down</option>
                    <option value="Up">Up</option>
                    <option value="Down">Down</option>
                    <option value="Random">Random</option>
                </select>
            </div>

            <div class="control-group">
                <label>AI Music Generation</label>
                <input type="text" id="ai-prompt" placeholder="Describe the music you want...">
                <button id="generate-ai-btn">Generate</button>
            </div>
            <div class="control-group">
                <label>Load Pattern (MIDI JSON)</label>
                <input type="file" id="midi-upload" accept=".json, .mid, .midi">
            </div>
            <div class="control-group">
                <button id="reset-btn">Reset Settings</button>
                <button id="hide-ui-btn">Hide UI</button>
            </div>
        </div>
    </div>
    <canvas id="matrix-bg"></canvas>
    <canvas id="visualizer"></canvas>
    <canvas id="histogram"></canvas>

    <script>
        let socket;
        let isPlaying = false;
        let isInitialized = false;
        let isReactive = false;

        // Audio components
        let kickSynth, bassSynth, leadSynth, leadFilter, sidechainGain;
        let leadLFO, leadDistortion, leadChorus, reactiveSignal;
        let chordSynth, pianoSynth, padSynth, arpSynth;
        let noiseSynth, snareSynth, noiseGate;
        let leadDelay, leadReverb, reverbFilter;
        let analyser, fftAnalyser, canvas, ctx, animationId, meter;
        let histCanvas, histCtx;

        // Matrix components
        let matrixCanvas, matrixCtx, matrixDrops = [], matrixHue = 120; // 120 is Hacker Green
        let matrixInterval;

        // MIDI components
        let midiAccess = null;
        let midiOut = null;
        let midiIn = null;

        // Toggle states
        let enabledInstruments = {
            kick: true,
            bass: true,
            lead: true,
            chords: true,
            piano: true,
            pads: true,
            arp: true
        };

        function logCode(line) {
            const container = document.getElementById('code-log');
            const el = document.createElement('div');
            el.className = 'code-line executed';
            el.innerText = line;
            container.appendChild(el);

            // Keep only latest lines
            while (container.childNodes.length > 15) {
                container.removeChild(container.firstChild);
            }

            // Smoothly remove "executed" class after animation
            setTimeout(() => el.classList.remove('executed'), 500);
        }

        function setupAudio() {
            // Optimizations from Tone.js Wiki & Tutorials
            Tone.context.latencyHint = "playback";
            Tone.context.lookAhead = 0.1;

            // Audio Link for Visuals
            meter = new Tone.Meter();
            Tone.Destination.connect(meter);

            // Safety: Master Gate and Limiter
            const masterGate = new Tone.Gate(-50).toDestination();
            const limiter = new Tone.Limiter(-1).connect(masterGate);

            const masterLP = new Tone.Filter({
                type: "lowpass",
                frequency: 12000,
                rolloff: -12
            }).connect(limiter);

            // "Air Cut" EQ3: highs pulled back by -5dB above 8kHz
            const masterEQ = new Tone.EQ3({
                low: 0,
                mid: 0,
                high: -5,
                highFrequency: 8000
            }).connect(masterLP);

            // Soft-Knee Compressor
            const masterComp = new Tone.Compressor({
                threshold: -20,
                ratio: 3,
                attack: 0.01,
                release: 0.25,
                knee: 30 // Soft-Knee
            }).connect(masterEQ);

            // Sidechain effect node
            sidechainGain = new Tone.Gain(1).connect(masterComp);

            // Noise Gate to prevent "Zombie" hiss
            noiseGate = new Tone.Gate(-50).connect(masterComp);

            // Kick Drum
            kickSynth = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 10,
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.02,
                    decay: 0.4,
                    sustain: 0.01,
                    release: 1.4,
                    attackCurve: "exponential"
                }
            }).connect(masterComp);

            // Bass Synth (SuperSaw)
            bassSynth = new Tone.PolySynth(Tone.MonoSynth, {
                oscillator: { type: "fatsawtooth6", count: 3, spread: 20 },
                envelope: {
                    attack: 0.02,
                    decay: 0.1,
                    sustain: 0.4,
                    release: 0.4,
                    releaseCurve: "exponential"
                },
                filterEnvelope: { attack: 0.02, decay: 0.1, sustain: 0.1, baseFrequency: 100, octaves: 2.5 }
            }).connect(sidechainGain);

            // Lead Synth (Hiss-Free FMSynth)
            leadFilter = new Tone.Filter({
                frequency: 1000,
                type: "lowpass",
                resonance: 8
            });

            leadDistortion = new Tone.Distortion(0.5);
            leadDistortion.wet.value = 0;

            leadChorus = new Tone.Chorus(4, 2.5, 0.5).start();
            leadChorus.wet.value = 0;

            // Signal Chain: Lead Filter -> Distortion -> Chorus -> Sidechain
            leadFilter.connect(leadDistortion);
            leadDistortion.connect(leadChorus);
            leadChorus.connect(sidechainGain);

            leadLFO = new Tone.LFO("4n", 400, 4000).start();
            leadLFO.connect(leadFilter.frequency);
            leadLFO.amplitude.setValueAtTime(0, Tone.now());

            reactiveSignal = new Tone.Signal(0);
            reactiveSignal.connect(leadFilter.frequency);

            leadDelay = new Tone.PingPongDelay({
                delayTime: "8n",
                feedback: 0.4,
                wet: 0.3
            }).connect(sidechainGain);

            reverbFilter = new Tone.Filter(4000, "lowpass").connect(sidechainGain);
            leadReverb = new Tone.Reverb({
                decay: 3,
                preDelay: 0.01,
                wet: 0.3
            }).connect(reverbFilter);

            leadSynth = new Tone.FMSynth({
                harmonicity: 1.5,
                modulationIndex: 5, // Clean/Glassy
                oscillator: { type: "sawtooth6" },
                envelope: {
                    attack: 0.02,
                    decay: 0.2,
                    sustain: 0.2,
                    release: 0.5,
                    releaseCurve: "exponential"
                },
                modulation: { type: "sine" },
                modulationEnvelope: { attack: 0.1, decay: 0.1, sustain: 1, release: 0.5 }
            }).connect(leadFilter);

            // Connect chorus output to parallel FX as well
            leadChorus.connect(leadDelay);
            leadDelay.connect(leadReverb);

            // Chord Synth
            chordSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 1 }
            }).connect(sidechainGain);
            chordSynth.volume.value = -10;

            // Piano Synth (Stylized)
            pianoSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 }
            }).connect(masterComp);
            pianoSynth.volume.value = -5;

            // Pad Synth
            padSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: { attack: 2, decay: 1, sustain: 0.8, release: 2 }
            }).connect(sidechainGain);
            padSynth.volume.value = -15;

            // Arp Synth
            arpSynth = new Tone.FMSynth({
                oscillator: { type: "square" },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
            }).connect(sidechainGain);
            arpSynth.volume.value = -12;

            // Noise Sampler (Replacement for NoiseSynth)
            // Procedurally generate a noise buffer
            const bufferSize = Tone.context.sampleRate * 4;
            const buffer = Tone.context.createBuffer(1, bufferSize, Tone.context.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noiseBuffer = new Tone.ToneAudioBuffer(buffer);

            noiseSynth = new Tone.Sampler({
                urls: { "C4": noiseBuffer },
                envelope: {
                    attack: 4,
                    release: 2,
                    releaseCurve: "exponential"
                }
            }).connect(noiseGate);

            snareSynth = new Tone.Sampler({
                urls: { "C4": noiseBuffer },
                envelope: {
                    attack: 0.02,
                    decay: 0.1,
                    sustain: 0,
                    release: 0.1,
                    releaseCurve: "exponential"
                }
            }).connect(noiseGate);

            // Visualizer Setup
            analyser = new Tone.Analyser("waveform", 1024);
            Tone.Destination.connect(analyser);

            fftAnalyser = new Tone.Analyser("fft", 256);
            Tone.Destination.connect(fftAnalyser);

            setupVisualizer();
            setupMatrix();
        }

        function setupMatrix() {
            matrixCanvas = document.getElementById("matrix-bg");
            matrixCtx = matrixCanvas.getContext("2d");

            const resize = () => {
                matrixCanvas.width = window.innerWidth;
                matrixCanvas.height = window.innerHeight;
                const columns = Math.floor(matrixCanvas.width / 20);
                matrixDrops = Array(columns).fill(1);
            };

            window.addEventListener("resize", resize);
            resize();

            const chars = "0123456789ABCDEF!@#$%^&*()_+-=[]{}|;:,.<>?/root@admin:~#".split("");

            matrixInterval = setInterval(() => {
                if (!isPlaying) return;

                // Audio Reactivity
                const level = Tone.dbToGain(meter.getValue());
                const speedBoost = 1 + level * 5;
                const glow = Math.floor(level * 20);

                matrixCtx.fillStyle = "rgba(0, 0, 0, 0.05)";
                matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

                matrixCtx.fillStyle = `hsla(${matrixHue}, 100%, 50%, ${0.5 + level})`;
                matrixCtx.font = "15px monospace";
                matrixCtx.shadowBlur = glow;
                matrixCtx.shadowColor = `hsl(${matrixHue}, 100%, 50%)`;

                for (let i = 0; i < matrixDrops.length; i++) {
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    matrixCtx.fillText(text, i * 20, matrixDrops[i] * 20);

                    if (matrixDrops[i] * 20 > matrixCanvas.height && Math.random() > 0.975) {
                        matrixDrops[i] = 0;
                    }

                    matrixDrops[i] += speedBoost;
                }
            }, 33); // ~30 FPS
        }

        function setupVisualizer() {
            canvas = document.getElementById("visualizer");
            ctx = canvas.getContext("2d");

            histCanvas = document.getElementById("histogram");
            histCtx = histCanvas.getContext("2d");

            window.addEventListener("resize", () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                histCanvas.width = window.innerWidth;
                histCanvas.height = window.innerHeight;
            });
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            histCanvas.width = window.innerWidth;
            histCanvas.height = window.innerHeight;
            draw();
        }

        function draw() {
            animationId = requestAnimationFrame(draw);

            // Reactive Synthesis Logic
            if (isReactive && reactiveSignal && meter) {
                const level = Tone.dbToGain(meter.getValue()); // 0 to 1
                const boost = level * 2000;
                // Use linear ramp to the new boost value for smoothness
                reactiveSignal.linearRampToValueAtTime(boost, Tone.now() + 0.05);
            } else if (reactiveSignal) {
                // Return to zero when disabled
                reactiveSignal.linearRampToValueAtTime(0, Tone.now() + 0.05);
            }

            // Waveform Visualizer
            const buffer = analyser.getValue();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#00ffcc";
            for (let i = 0; i < buffer.length; i++) {
                const x = (i / buffer.length) * canvas.width;
                const y = ((buffer[i] + 1) / 2) * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Histogram (FFT)
            if (fftAnalyser) {
                const fftData = fftAnalyser.getValue();
                histCtx.clearRect(0, 0, histCanvas.width, histCanvas.height);
                const barWidth = (histCanvas.width / fftData.length) * 2.5;
                let x = 0;

                for (let i = 0; i < fftData.length; i++) {
                    // FFT data is in dB, typically -100 to 0
                    const barHeight = (fftData[i] + 100) * (histCanvas.height / 100);
                    histCtx.fillStyle = "#00ffcc";
                    histCtx.fillRect(x, histCanvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
        }

        function triggerSidechain(time) {
            sidechainGain.gain.cancelScheduledValues(time);
            sidechainGain.gain.setValueAtTime(1, time);
            // -10dB volume dip (approx 0.316) with 0.05s rampTime
            sidechainGain.gain.rampTo(0.316, 0.05, time);
            sidechainGain.gain.rampTo(1, 0.1, time + 0.05);
        }

        async function initMIDI() {
            if (navigator.requestMIDIAccess) {
                try {
                    midiAccess = await navigator.requestMIDIAccess({ sysex: true, software: true });
                    updateMIDIDevices();
                    midiAccess.onstatechange = updateMIDIDevices;
                } catch (e) {
                    console.error("MIDI Access Denied", e);
                }
            }
        }

        function updateMIDIDevices() {
            const outSelect = document.getElementById("midi-out-select");
            const inSelect = document.getElementById("midi-in-select");

            const currentOut = outSelect.value;
            const currentIn = inSelect.value;

            outSelect.innerHTML = '<option value="none">None (Internal Only)</option>';
            inSelect.innerHTML = '<option value="none">None</option>';

            midiAccess.outputs.forEach((output) => {
                const option = document.createElement("option");
                option.value = output.id;
                option.text = output.name;
                outSelect.appendChild(option);
            });

            midiAccess.inputs.forEach((input) => {
                const option = document.createElement("option");
                option.value = input.id;
                option.text = input.name;
                inSelect.appendChild(option);
            });

            outSelect.value = currentOut;
            inSelect.value = currentIn;
        }

        function sendMIDINote(note, duration, time, channel = 0) {
            if (!midiOut) return;
            const noteNum = Tone.Frequency(note).toMidi();
            const velocity = 0x7f;
            const onMsg = [0x90 + channel, noteNum, velocity];
            const offMsg = [0x80 + channel, noteNum, velocity];

            // Scheduling MIDI is harder, we use setTimeout as a fallback for simple demo
            const delay = (time - Tone.now()) * 1000;
            const durMs = Tone.Time(duration).toMilliseconds();

            setTimeout(() => {
                midiOut.send(onMsg);
                setTimeout(() => midiOut.send(offMsg), durMs);
            }, Math.max(0, delay));
        }

        async function handleMIDIPattern(file) {
            if (file.name.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const pattern = JSON.parse(e.target.result);
                    socket.emit('update_pattern', pattern);
                };
                reader.readAsText(file);
            } else {
                // Parse .mid file using @tonejs/midi
                const arrayBuffer = await file.arrayBuffer();
                const midi = new Midi(arrayBuffer);
                socket.emit('update_pattern', midi.toJSON());
            }
        }

        function handleMIDIIn(event) {
            const [status, data1, data2] = event.data;
            const type = status & 0xf0;
            const channel = status & 0x0f;

            if (type === 0xb0) { // CC
                if (data1 === 74) { // Brightness/Cutoff
                    const val = (data2 / 127) * 8600 + 400; // Map 0-127 to 400-9000
                    if (leadFilter) leadFilter.frequency.rampTo(val, 0.05);
                    document.getElementById('cutoff-slider').value = val;
                }
            }

            // Basic Clock Sync (0xF8) - very simplified
            if (status === 0xf8) {
                // In a real app, we'd calculate BPM from clock pulses
                // 24 pulses per quarter note
            }
        }

        // Timing management to prevent conflicts
        let lastTriggerTime = 0;
        const minInterval = 0.001; // 1ms minimum between triggers

        function getSafeTime() {
            const now = Tone.now();
            const proposedTime = now + Math.random() * 0.01 + 0.2; // Increased lookahead for network latency
            if (proposedTime <= lastTriggerTime + minInterval) {
                lastTriggerTime = lastTriggerTime + minInterval;
                return lastTriggerTime;
            }
            lastTriggerTime = proposedTime;
            return proposedTime;
        }

        function initSocket() {
            socket = io({
                transports: ['websocket'],
                upgrade: false,
                rememberUpgrade: false
            });

            socket.on('trigger_sidechain', () => {
                
                
                triggerSidechain(getSafeTime());
                logCode("with_fx :sidechain do");
            });

            socket.on('trigger_kick', (data) => {
                
                 // Add jitter to prevent timing conflicts
                const time = getSafeTime();
                kickSynth.triggerAttackRelease(data.note, data.duration, time);
                sendMIDINote(data.note, data.duration, time, 9); // Channel 10 (drums)
                logCode(`  sample :bd_haus, rate: 1, amp: 1`);
            });

            socket.on('trigger_bass', (data) => {
                
                
                const time = getSafeTime();
                bassSynth.triggerAttackRelease(data.note, data.duration, time);
                sendMIDINote(data.note, data.duration, time, 1); // Channel 2
                logCode(`  play :${data.note.replace('1', '')}1, release: 0.1, synth: :prophet`);
            });

            socket.on('trigger_lead', (data) => {
                
                
                const time = getSafeTime();

                // Harmonic Tracking (Key Follow): Base Cutoff = Note Frequency * 3
                const freq = Tone.Frequency(data.note).toFrequency();
                const baseCutoff = freq * 3;

                // Resonance Safety (Q-Limit): Lower Q as frequency increases
                const currentQ = Math.max(1, 15 - (baseCutoff / 1000));

                leadFilter.frequency.setValueAtTime(baseCutoff, time);
                leadFilter.Q.setValueAtTime(currentQ, time);

                leadSynth.detune.setValueAtTime(data.detune, time);
                leadSynth.triggerAttackRelease(data.note, data.duration, time);
                sendMIDINote(data.note, data.duration, time, 0); // Channel 1
                logCode(`  play :${data.note}, detune: ${data.detune.toFixed(2)}`);
            });

            socket.on('trigger_riser', (data) => {
                
                
                noiseSynth.triggerAttack("C4", getSafeTime());
                // Release after duration in bars
                const durationSeconds = (60 / 140) * 4 * data.duration;
                noiseSynth.triggerRelease("C4", getSafeTime() + durationSeconds);
                logCode(`  sample :ambi_whitenoise, sustain: ${data.duration * 4}`);
            });

            socket.on('trigger_snare', (data) => {
                
                
                snareSynth.triggerAttackRelease("C4", data.duration, getSafeTime());
                logCode(`  sample :sn_dnb, amp: 0.5`);
            });

            socket.on('trigger_chords', (data) => {
                
                
                chordSynth.triggerAttackRelease(data.notes, data.duration, getSafeTime());
                logCode(`  play_chord [:${data.notes.join(', :')}], release: 1`);
            });

            socket.on('trigger_piano', (data) => {
                
                
                pianoSynth.triggerAttackRelease(data.note, data.duration, getSafeTime());
                logCode(`  play :${data.note}, synth: :piano`);
            });

            socket.on('trigger_pads', (data) => {
                
                
                padSynth.triggerAttackRelease(data.note, data.duration, getSafeTime());
                logCode(`  play :${data.note}, release: 4, synth: :hollow`);
            });

            socket.on('trigger_arp', (data) => {
                
                
                arpSynth.triggerAttackRelease(data.note, data.duration, getSafeTime());
                logCode(`  play :${data.note}, synth: :arp`);
            });

            socket.on('param_update', (data) => {
                if (data.param === 'lead_cutoff') {
                    // Clamp between 400Hz and 9000Hz
                    const clampedVal = Math.max(400, Math.min(9000, data.value));

                    // Resonance Safety applied during sweeps too
                    const currentQ = Math.max(1, 15 - (clampedVal / 1000));

                    leadFilter.frequency.linearRampToValueAtTime(clampedVal, Tone.now() + 0.05);
                    leadFilter.Q.linearRampToValueAtTime(currentQ, Tone.now() + 0.05);
                    logCode(`control :lead, cutoff: ${clampedVal.toFixed(0)}`);
                } else if (data.param === 'bass_spread') {
                    if (bassSynth && bassSynth.voices) {
                        // Use rampTime of 0.05s on all voices
                        bassSynth.voices.forEach(voice => {
                            if (voice.oscillator && voice.oscillator.spread) {
                                voice.oscillator.spread.linearRampToValueAtTime(data.value, Tone.now() + 0.05);
                            }
                        });
                    }
                }
            });

            socket.on('state_change', (data) => {
                document.getElementById('state-display').innerText = `State: ${data.state} (Bar ${data.bar})`;

                // Randomize Matrix Hue on state change
                // Groove: Green(120), Breakdown: Purple(280), Build: Orange(30), Drop: Red(0)
                if (data.state === "Groove") matrixHue = 120;
                else if (data.state === "Breakdown") matrixHue = 280;
                else if (data.state === "Build-up") matrixHue = 30;
                else if (data.state === "Drop") matrixHue = 0;

                // Nuclear Fix 3: Hard Mute Noise during Breakdown
                if (data.state === "Breakdown") {
                    if (noiseSynth) noiseSynth.volume.rampTo(-Infinity, 0.05);
                    if (snareSynth) snareSynth.volume.rampTo(-Infinity, 0.05);
                } else {
                    if (noiseSynth) noiseSynth.volume.rampTo(0, 0.05);
                    if (snareSynth) snareSynth.volume.rampTo(0, 0.05);
                }
                logCode(`# Transition to ${data.state.toUpperCase()}`);
            });
        }

        function setupUI() {
            document.getElementById("midi-upload").addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (file) handleMIDIPattern(file);
            });

            document.getElementById("midi-out-select").addEventListener("change", (e) => {
                if (e.target.value === "none") {
                    midiOut = null;
                } else {
                    midiOut = midiAccess.outputs.get(e.target.value);
                }
            });

            document.getElementById("midi-in-select").addEventListener("change", (e) => {
                if (midiIn) midiIn.onmidimessage = null;
                if (e.target.value === "none") {
                    midiIn = null;
                } else {
                    midiIn = midiAccess.inputs.get(e.target.value);
                    midiIn.onmidimessage = handleMIDIIn;
                }
            });

            document.getElementById('cutoff-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (leadFilter) leadFilter.frequency.linearRampToValueAtTime(val, Tone.now() + 0.1);
            });

            document.getElementById('width-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (bassSynth && bassSynth.voices) {
                    bassSynth.voices.forEach(voice => {
                        if (voice.oscillator && voice.oscillator.spread) {
                            voice.oscillator.spread.linearRampToValueAtTime(val, Tone.now() + 0.1);
                        }
                    });
                }
            });

            document.getElementById('reverb-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value) / 100;
                if (leadReverb) leadReverb.wet.linearRampToValueAtTime(val, Tone.now() + 0.1);
            });

            document.getElementById('seed-select').addEventListener('change', (e) => {
                const val = e.target.value;
                if (val === "none") {
                    socket.emit('reset_pattern');
                } else {
                    socket.emit('set_seed_pattern', { name: val });
                }
                logCode(`# Seed Pattern set to ${val.toUpperCase()}`);
            });

            document.getElementById('mutation-slider').addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                socket.emit('set_mutation', { value: val });
                logCode(`# Mutation set to ${val}%`);
            });

            document.getElementById('lfo-rate-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (leadLFO) leadLFO.frequency.linearRampToValueAtTime(val, Tone.now() + 0.1);
                logCode(`# LFO Rate set to ${val}Hz`);
            });

            document.getElementById('lfo-depth-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (leadLFO) leadLFO.amplitude.linearRampToValueAtTime(val, Tone.now() + 0.1);
                logCode(`# LFO Depth set to ${val}`);
            });

            document.getElementById('distortion-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value) / 100;
                if (leadDistortion) leadDistortion.wet.linearRampToValueAtTime(val, Tone.now() + 0.1);
                logCode(`# Lead Distortion set to ${val.toFixed(2)}`);
            });

            document.getElementById('chorus-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value) / 100;
                if (leadChorus) leadChorus.wet.linearRampToValueAtTime(val, Tone.now() + 0.1);
                logCode(`# Lead Chorus set to ${val.toFixed(2)}`);
            });

            document.getElementById('reactive-checkbox').addEventListener('change', (e) => {
                isReactive = e.target.checked;
                logCode(`# Reactive Mode ${isReactive ? 'ENABLED' : 'DISABLED'}`);
            });

            document.getElementById('arp-mode-select').addEventListener('change', (e) => {
                const val = e.target.value;
                socket.emit('set_arp_mode', { mode: val });
                logCode(`# Arp Mode set to ${val.toUpperCase()}`);
            });

            document.getElementById('generate-ai-btn').addEventListener('click', async () => {
                const prompt = document.getElementById('ai-prompt').value;
                if (!prompt) return;
                
                logCode(`# Generating AI music: ${prompt}`);
                try {
                    const response = await fetch('/api/generate-music', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt })
                    });
                    const params = await response.json();
                    logCode(`# AI generated: BPM ${params.bpm}, Pattern ${params.melody_pattern}`);
                } catch (error) {
                    logCode('# AI generation failed');
                }
            });

            document.getElementById('reset-btn').addEventListener('click', () => {
                // Reset Sliders
                document.getElementById('cutoff-slider').value = 1000;
                document.getElementById('width-slider').value = 20;
                document.getElementById('reverb-slider').value = 30;
                document.getElementById('mutation-slider').value = 0;
                document.getElementById('lfo-rate-slider').value = 1;
                document.getElementById('lfo-depth-slider').value = 0;
                document.getElementById('distortion-slider').value = 0;
                document.getElementById('chorus-slider').value = 0;
                document.getElementById('reactive-checkbox').checked = false;
                isReactive = false;
                document.getElementById('arp-mode-select').value = "UpDown";
                document.getElementById('seed-select').value = "none";

                // Reset Audio Params
                if (leadFilter) leadFilter.frequency.linearRampToValueAtTime(1000, Tone.now() + 0.1);
                if (bassSynth && bassSynth.voices) {
                    bassSynth.voices.forEach(voice => {
                        if (voice.oscillator && voice.oscillator.spread) {
                            voice.oscillator.spread.linearRampToValueAtTime(20, Tone.now() + 0.1);
                        }
                    });
                }
                if (leadReverb) leadReverb.wet.linearRampToValueAtTime(0.3, Tone.now() + 0.1);
                if (leadLFO) {
                    leadLFO.frequency.linearRampToValueAtTime(1, Tone.now() + 0.1);
                    leadLFO.amplitude.linearRampToValueAtTime(0, Tone.now() + 0.1);
                }
                if (leadDistortion) leadDistortion.wet.linearRampToValueAtTime(0, Tone.now() + 0.1);
                if (leadChorus) leadChorus.wet.linearRampToValueAtTime(0, Tone.now() + 0.1);

                // Reset Pattern on Backend
                if (socket) socket.emit('reset_pattern');
            });

            document.getElementById('hide-ui-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                document.getElementById('ui-container').style.display = 'none';
            });

            window.addEventListener('click', () => {
                const ui = document.getElementById('ui-container');
                if (ui.style.display === 'none') {
                    ui.style.display = 'block';
                }
            });

            // Instrument Toggles
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const inst = btn.getAttribute('data-inst');
                    enabledInstruments[inst] = !enabledInstruments[inst];
                    btn.classList.toggle('active', enabledInstruments[inst]);

                    // Update Mute State
                    const synths = {
                        kick: [kickSynth],
                        bass: [bassSynth],
                        lead: [leadSynth],
                        chords: [chordSynth],
                        piano: [pianoSynth],
                        pads: [padSynth],
                        arp: [arpSynth]
                    };

                    if (synths[inst]) {
                        synths[inst].forEach(s => {
                            if (s) s.volume.mute = !enabledInstruments[inst];
                        });
                    }

                    logCode(`# Instrument ${inst.toUpperCase()} ${enabledInstruments[inst] ? 'ENABLED' : 'DISABLED'}`);
                });
            });
        }

        document.getElementById("start-stop-btn").addEventListener("click", async () => {
            if (!isPlaying) {
                try {
                    await Tone.start();
                    console.log('Audio context started successfully');
                } catch (error) {
                    console.error('Failed to start audio context:', error);
                    return;
                }
                if (!isInitialized) {
                    setupAudio();
                    await initMIDI();
                    setupUI();
                    initSocket();
                    isInitialized = true;
                }
                socket.emit('start_music');
                isPlaying = true;
                document.getElementById("start-stop-btn").innerText = "STOP";
            } else {
                if (socket) socket.emit('stop_music');
                isPlaying = false;
                document.getElementById("start-stop-btn").innerText = "START";
                document.getElementById("state-display").innerText = "State: Stopped";
            }
        });
    </script>
</body>
</html>
