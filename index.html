<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generative Trance - Python Brain + Tone.js</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js" integrity="sha512-jduERlz7En1IUZR54bqzpNI64AbffZWR//KJgF71SJ8D8/liKFZ+s1RxmUmB+bhCnIfzebdZsULwOrbVB5f3nQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://unpkg.com/@tonejs/midi"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <div id="loading-overlay">
        <h1>LOADING SAMPLES...</h1>
    </div>
    <div id="code-log"></div>
    <div id="ui-container">
        <h1>Generative Trance</h1>
        <p id="state-display">State: Stopped</p>
        <button id="start-stop-btn" class="main-action-btn">START</button>
        <button id="mixer-toggle-btn" class="main-action-btn">MIXER</button>

        <div id="instrument-toggles">
            <button class="toggle-btn active" data-inst="kick">KICK</button>
            <button class="toggle-btn active" data-inst="bass">BASS</button>
            <button class="toggle-btn active" data-inst="lead">SYNTH</button>
            <button class="toggle-btn active" data-inst="chords">CHORDS</button>
            <button class="toggle-btn active" data-inst="piano">PIANO</button>
            <button class="toggle-btn active" data-inst="pads">PADS</button>
            <button class="toggle-btn active" data-inst="arp">ARP</button>
        </div>

        <div id="controls">
            <div class="control-group">
                <label>BPM</label>
                <input type="range" id="bpm-slider" min="125" max="150" value="140">
                <span id="bpm-display">140</span>
            </div>
            <div class="control-group">
                <label>Acid Cutoff</label>
                <input type="range" id="cutoff-slider" min="400" max="9000" value="1000">
            </div>
            <div class="control-group">
                <label>SuperSaw Width</label>
                <input type="range" id="width-slider" min="0" max="100" value="20">
            </div>
            <div class="control-group">
                <label>Reverb Mix</label>
                <input type="range" id="reverb-slider" min="0" max="100" value="30">
            </div>
            <div class="control-group">
                <label>MIDI Out</label>
                <select id="midi-out-select">
                    <option value="none">None (Internal Only)</option>
                </select>
            </div>
            <div class="control-group">
                <label>MIDI In</label>
                <select id="midi-in-select">
                    <option value="none">None</option>
                </select>
            </div>
            <div class="control-group">
                <label>Melodic Seed</label>
                <select id="seed-select">
                    <option value="none">None (Generative)</option>
                    <option value="uplifting_arp">Uplifting Arp</option>
                    <option value="rolling_bassline">Rolling Bassline</option>
                    <option value="acid_sequence">Acid Sequence</option>
                </select>
            </div>
            <div class="control-group">
                <label>Mutation</label>
                <input type="range" id="mutation-slider" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>LFO Rate</label>
                <input type="range" id="lfo-rate-slider" min="0.1" max="10" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>LFO Depth</label>
                <input type="range" id="lfo-depth-slider" min="0" max="1" step="0.01" value="0">
            </div>
            <div class="control-group">
                <label>Distortion</label>
                <input type="range" id="distortion-slider" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>Chorus</label>
                <input type="range" id="chorus-slider" min="0" max="100" value="0">
            </div>
            <div class="control-group">
                <label>Reactive Mode</label>
                <input type="checkbox" id="reactive-checkbox">
            </div>
            <div class="control-group">
                <label>Background Loop</label>
                <input type="checkbox" id="background-loop-checkbox" checked>
            </div>
            <div class="control-group">
                <label>Arp Mode</label>
                <select id="arp-mode-select">
                    <option value="UpDown">Up-Down</option>
                    <option value="Up">Up</option>
                    <option value="Down">Down</option>
                    <option value="Random">Random</option>
                </select>
            </div>

            <div class="control-group">
                <label>AI Music Generation</label>
                <input type="text" id="ai-prompt" placeholder="Describe the music you want...">
                <button id="generate-ai-btn">Generate</button>
            </div>
            <div class="control-group">
                <label>Load Pattern (MIDI JSON)</label>
                <input type="file" id="midi-upload" accept=".json, .mid, .midi">
            </div>
            <div class="control-group">
                <button id="save-midi-btn">Save MIDI</button>
                <button id="reset-btn">Reset Settings</button>
                <button id="hide-ui-btn">Hide UI</button>
            </div>
        </div>

        <div id="mixer-controls" style="display: none;">
            <h2>Mixer</h2>
            <div class="control-group">
                <label>Kick Volume</label>
                <input type="range" id="kick-volume-slider" data-inst="kick" min="-40" max="0" value="-6" step="1">
            </div>
            <div class="control-group">
                <label>Bass Volume</label>
                <input type="range" id="bass-volume-slider" data-inst="bass" min="-40" max="0" value="-6" step="1">
            </div>
            <div class="control-group">
                <label>Lead Volume</label>
                <input type="range" id="lead-volume-slider" data-inst="lead" min="-40" max="0" value="-12" step="1">
            </div>
            <div class="control-group">
                <label>Chords Volume</label>
                <input type="range" id="chords-volume-slider" data-inst="chords" min="-40" max="0" value="-10" step="1">
            </div>
            <div class="control-group">
                <label>Piano Volume</label>
                <input type="range" id="piano-volume-slider" data-inst="piano" min="-40" max="0" value="-5" step="1">
            </div>
            <div class="control-group">
                <label>Pads Volume</label>
                <input type="range" id="pads-volume-slider" data-inst="pads" min="-40" max="0" value="-15" step="1">
            </div>
            <div class="control-group">
                <label>Arp Volume</label>
                <input type="range" id="arp-volume-slider" data-inst="arp" min="-40" max="0" value="-12" step="1">
            </div>
            <button id="back-to-main-controls-btn">BACK</button>
        </div>
    </div>
    <canvas id="matrix-bg"></canvas>
    <canvas id="visualizer"></canvas>
    <canvas id="histogram"></canvas>

    <script>
        // Strudel-style Pattern Logic
        class PatternCycle {
            constructor(pattern, scale) {
                this.pattern = pattern; // e.g. [14, 18, 14, 23, 21]
                this.scale = scale;
                this.step = 0;
            }
            next() {
                const index = this.pattern[this.step % this.pattern.length];
                this.step++;
                return this.scale[index];
            }
        }

        // Switch Angel style Trance Gate
        class TranceGate {
            constructor() {
                this.mask = [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1];
            }
            evolve() {
                // Randomly flip bits (0 to 1) every 4 bars
                const idx = Math.floor(Math.random() * 16);
                this.mask[idx] = 1 - this.mask[idx];
                logCode(`# Trance Gate Evolved: ${this.mask.slice(0, 8).join('')}...`);
            }
            get(index) {
                return this.mask[index % 16];
            }
        }

        // Cache bust v2.0 - Fixed Sampler issues
        let socket;
        let isPlaying = false;
        let isInitialized = false;
        let isReactive = false;
        let audioStarted = false;

        // Audio components
        let kickSynth, bassSynth, leadSynth, leadFilter, sidechainGain;
        let bassGate, tranceGate, melodyCycle;
        let leadLFO, leadDistortion, leadChorus, reactiveSignal;
        let chordSynth, pianoSynth, padSynth, arpSynth;
        let noiseSynth, snareSynth, noiseGate, topLoopPlayer;
        let leadDelay, leadReverb, reverbFilter;

        // MIDI Recording
        let recordedNotes = [];
        let melodyLoop;
        const G_MINOR_SCALE = ["G1", "A1", "Bb1", "C2", "D2", "Eb2", "F2", "G2", "A2", "Bb2", "C3", "D3", "Eb3", "F3", "G3", "A3", "Bb3", "C4", "D4", "Eb4", "F4", "G4", "A4", "Bb4"];
        let analyser, fftAnalyser, canvas, ctx, animationId, meter;
        let histCanvas, histCtx;

        // Matrix components
        let matrixCanvas, matrixCtx, matrixDrops = [], matrixHue = 120; // 120 is Hacker Green
        let matrixInterval;

        // MIDI components
        let midiAccess = null;
        let midiOut = null;
        let midiIn = null;

        // Toggle states
        let enabledInstruments = {
            kick: true,
            bass: true,
            lead: true,
            chords: true,
            piano: true,
            pads: true,
            arp: true
        };

        function logCode(line) {
            const container = document.getElementById('code-log');
            const el = document.createElement('div');
            el.className = 'code-line executed';
            el.innerText = line;
            container.appendChild(el);

            // Keep only latest lines
            while (container.childNodes.length > 15) {
                container.removeChild(container.firstChild);
            }

            // Smoothly remove "executed" class after animation
            setTimeout(() => el.classList.remove('executed'), 500);
        }

        function setupAudio() {
            // Optimizations from Tone.js Wiki & Tutorials
            Tone.context.latencyHint = "playback";
            Tone.context.lookAhead = 0.1;

            // Audio Link for Visuals
            meter = new Tone.Meter();
            Tone.Destination.connect(meter);

            // Safety: Master Gate and Limiter
            const masterGate = new Tone.Gate(-50).toDestination();
            const limiter = new Tone.Limiter(-1).connect(masterGate);

            const masterLP = new Tone.Filter({
                type: "lowpass",
                frequency: 12000,
                rolloff: -12
            }).connect(limiter);

            // "Air Cut" EQ3: highs pulled back by -5dB above 8kHz
            const masterEQ = new Tone.EQ3({
                low: 0,
                mid: 0,
                high: -5,
                highFrequency: 8000
            }).connect(masterLP);

            // Soft-Knee Compressor
            const masterComp = new Tone.Compressor({
                threshold: -20,
                ratio: 3,
                attack: 0.01,
                release: 0.25,
                knee: 30 // Soft-Knee
            }).connect(masterEQ);

            // Sidechain effect node
            sidechainGain = new Tone.Gain(1).connect(masterComp);

            // Trance Gate (Switch Angel style)
            tranceGate = new TranceGate();
            bassGate = new Tone.Gain(1).connect(sidechainGain);

            // Noise Gate to prevent "Zombie" hiss
            noiseGate = new Tone.Gate(-50).connect(masterComp);

            // Kick Drum (Trance-style with sub bass)
            kickSynth = new Tone.MembraneSynth({
                pitchDecay: 0.008,
                octaves: 4,
                oscillator: { type: "sine" },
                envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.2 }
            }).connect(masterComp);
            kickSynth.volume.value = 0;

            // Bass Synth (Trance supersaw bass)
            bassSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { 
                    type: "fatsawtooth",
                    count: 3,
                    spread: 30
                },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.4 },
                filter: { frequency: 350, type: "lowpass", rolloff: -24 },
                filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.4, baseFrequency: 200, octaves: 2 }
            }).connect(bassGate); // Routed through Trance Gate
            bassSynth.volume.value = -6;

            // Lead Synth (Hiss-Free FMSynth)
            // Lead Filter (Classic trance filter sweep)
            leadFilter = new Tone.Filter({
                frequency: 600,
                type: "lowpass",
                rolloff: -24,
                Q: 4
            });

            // Arp Filter for taming high frequencies
            const arpFilter = new Tone.Filter({
                frequency: 800, // Start with a reasonable cutoff
                type: "lowpass",
                rolloff: -12,
                Q: 2 // Gentle resonance
            });

            leadDistortion = new Tone.Distortion(0.5);
            leadDistortion.wet.value = 0;

            leadChorus = new Tone.Chorus(4, 2.5, 0.5).start();
            leadChorus.wet.value = 0;

            // Signal Chain: Lead Filter -> Distortion -> Chorus -> Sidechain
            leadFilter.connect(leadDistortion);
            leadDistortion.connect(leadChorus);
            leadChorus.connect(sidechainGain);

            // Trance-style LFO for filter sweeps
            leadLFO = new Tone.LFO("2n", 400, 900).start();
            leadLFO.connect(leadFilter.frequency);
            leadLFO.amplitude.setValueAtTime(0.8, Tone.now());

            reactiveSignal = new Tone.Signal(0);
            reactiveSignal.connect(leadFilter.frequency);

            leadDelay = new Tone.PingPongDelay({
                delayTime: "8n",
                feedback: 0.4,
                wet: 0.3
            }).connect(sidechainGain);

            reverbFilter = new Tone.Filter(4000, "lowpass").connect(sidechainGain);
            leadReverb = new Tone.Reverb({
                decay: 3,
                preDelay: 0.01,
                wet: 0.3
            }).connect(reverbFilter);

            // Lead Synth (Trance pluck/lead)
            leadSynth = new Tone.PolySynth(Tone.Synth, {
                volume: -12,
                oscillator: { 
                    type: "fatsawtooth",
                    count: 3,
                    spread: 40
                },
                envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.8 },
                filter: { frequency: 1200, type: "lowpass", rolloff: -12 },
                filterEnvelope: { attack: 0.01, decay: 0.3, sustain: 0.35, release: 1.2, baseFrequency: 600, octaves: 1 }
            }).connect(leadFilter);

            // Connect chorus output to parallel FX as well
            leadChorus.connect(leadDelay);
            leadDelay.connect(leadReverb);

            // Chord Synth
            chordSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 1 }
            }).connect(sidechainGain);
            chordSynth.volume.value = -10;

            // Piano Synth (Stylized)
            pianoSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 }
            }).connect(masterComp);
            pianoSynth.volume.value = -5;

            // Pad Synth
            padSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "triangle" },
                envelope: { attack: 2, decay: 1, sustain: 0.8, release: 2 }
            }).connect(sidechainGain);
            padSynth.volume.value = -15;

            // Arp Synth
            arpSynth = new Tone.FMSynth({
                oscillator: { type: "square" },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }
            }).connect(arpFilter);
            arpFilter.connect(sidechainGain);
            arpSynth.volume.value = -12;

            // FX Synth (White Noise) - Simplified
            noiseSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: { attack: 0.1, decay: 0.2, sustain: 0.1, release: 0.8 }
            }).connect(noiseGate);
            noiseSynth.volume.value = -20;

            // Snare Synth (NoiseSynth - reliable)
            snareSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.0 }
            }).connect(noiseGate);
            snareSynth.volume.value = -6;

            // BPM-Synced Loop - Simplified oscillator instead of external sample
            topLoopPlayer = new Tone.Oscillator({
                frequency: 55,
                type: "sawtooth"
            }).connect(masterComp);
            topLoopPlayer.volume.value = -25;

            // Visualizer Setup
            analyser = new Tone.Analyser("waveform", 1024);
            Tone.Destination.connect(analyser);

            fftAnalyser = new Tone.Analyser("fft", 256);
            Tone.Destination.connect(fftAnalyser);

            setupVisualizer();
            setupMatrix();
        }

        function setupMatrix() {
            matrixCanvas = document.getElementById("matrix-bg");
            matrixCtx = matrixCanvas.getContext("2d");

            const resize = () => {
                matrixCanvas.width = window.innerWidth;
                matrixCanvas.height = window.innerHeight;
                const columns = Math.floor(matrixCanvas.width / 20);
                matrixDrops = Array(columns).fill(1);
            };

            window.addEventListener("resize", resize);
            resize();

            const chars = "0123456789ABCDEF!@#$%^&*()_+-=[]{}|;:,.<>?/root@admin:~#".split("");

            matrixInterval = setInterval(() => {
                if (!isPlaying) return;

                // Audio Reactivity (linked to dropSpeed)
                const level = Tone.dbToGain(meter ? meter.getValue() : -Infinity);
                const dropSpeed = 1 + level * 10; // faster during drops, slower during breakdowns
                const glow = Math.floor(level * 25);

                matrixCtx.fillStyle = "rgba(0, 0, 0, 0.05)";
                matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);

                matrixCtx.fillStyle = `hsla(${matrixHue}, 100%, 50%, ${0.5 + level})`;
                matrixCtx.font = "15px monospace";
                matrixCtx.shadowBlur = glow;
                matrixCtx.shadowColor = `hsl(${matrixHue}, 100%, 50%)`;

                for (let i = 0; i < matrixDrops.length; i++) {
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    matrixCtx.fillText(text, i * 20, matrixDrops[i] * 20);

                    if (matrixDrops[i] * 20 > matrixCanvas.height && Math.random() > 0.975) {
                        matrixDrops[i] = 0;
                    }

                    matrixDrops[i] += dropSpeed;
                }
            }, 33); // ~30 FPS
        }

        function setupVisualizer() {
            canvas = document.getElementById("visualizer");
            ctx = canvas.getContext("2d");

            histCanvas = document.getElementById("histogram");
            histCtx = histCanvas.getContext("2d");

            window.addEventListener("resize", () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                histCanvas.width = window.innerWidth;
                histCanvas.height = window.innerHeight;
            });
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            histCanvas.width = window.innerWidth;
            histCanvas.height = window.innerHeight;
            draw();
        }

        function draw() {
            animationId = requestAnimationFrame(draw);

            // Reactive Synthesis Logic
            if (isReactive && reactiveSignal && meter) {
                const level = Tone.dbToGain(meter.getValue()); // 0 to 1
                const boost = level * 2000;
                // Use linear ramp to the new boost value for smoothness
                reactiveSignal.linearRampToValueAtTime(boost, Tone.now() + 0.05);
            } else if (reactiveSignal) {
                // Return to zero when disabled
                reactiveSignal.linearRampToValueAtTime(0, Tone.now() + 0.05);
            }

            // Waveform Visualizer
            const buffer = analyser.getValue();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#00ffcc";
            for (let i = 0; i < buffer.length; i++) {
                const x = (i / buffer.length) * canvas.width;
                const y = ((buffer[i] + 1) / 2) * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Histogram (FFT)
            if (fftAnalyser) {
                const fftData = fftAnalyser.getValue();
                histCtx.clearRect(0, 0, histCanvas.width, histCanvas.height);
                const barWidth = (histCanvas.width / fftData.length) * 2.5;
                let x = 0;

                for (let i = 0; i < fftData.length; i++) {
                    // FFT data is in dB, typically -100 to 0
                    const barHeight = (fftData[i] + 100) * (histCanvas.height / 100);
                    histCtx.fillStyle = "#00ffcc";
                    histCtx.fillRect(x, histCanvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
        }

        function triggerSidechain(time) {
            sidechainGain.gain.cancelScheduledValues(time);
            sidechainGain.gain.setValueAtTime(1, time);
            // -10dB volume dip (approx 0.316) with 0.05s rampTime
            sidechainGain.gain.rampTo(0.316, 0.05, time);
            sidechainGain.gain.rampTo(1, 0.1, time + 0.05);
        }

        async function initMIDI() {
            if (navigator.requestMIDIAccess) {
                try {
                    midiAccess = await navigator.requestMIDIAccess({ sysex: true, software: true });
                    updateMIDIDevices();
                    midiAccess.onstatechange = updateMIDIDevices;
                } catch (e) {
                    console.error("MIDI Access Denied", e);
                }
            }
        }

        function updateMIDIDevices() {
            const outSelect = document.getElementById("midi-out-select");
            const inSelect = document.getElementById("midi-in-select");

            const currentOut = outSelect.value;
            const currentIn = inSelect.value;

            outSelect.innerHTML = '<option value="none">None (Internal Only)</option>';
            inSelect.innerHTML = '<option value="none">None</option>';

            midiAccess.outputs.forEach((output) => {
                const option = document.createElement("option");
                option.value = output.id;
                option.text = output.name;
                outSelect.appendChild(option);
            });

            midiAccess.inputs.forEach((input) => {
                const option = document.createElement("option");
                option.value = input.id;
                option.text = input.name;
                inSelect.appendChild(option);
            });

            outSelect.value = currentOut;
            inSelect.value = currentIn;
        }

        function sendMIDINote(note, duration, time, channel = 0) {
            if (!midiOut) return;
            const noteNum = Tone.Frequency(note).toMidi();
            const velocity = 0x7f;
            const onMsg = [0x90 + channel, noteNum, velocity];
            const offMsg = [0x80 + channel, noteNum, velocity];

            // Scheduling MIDI is harder, we use setTimeout as a fallback for simple demo
            const delay = (time - Tone.now()) * 1000;
            const durMs = Tone.Time(duration).toMilliseconds();

            setTimeout(() => {
                midiOut.send(onMsg);
                setTimeout(() => midiOut.send(offMsg), durMs);
            }, Math.max(0, delay));
        }

        async function handleMIDIPattern(file) {
            if (file.name.endsWith('.json')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const pattern = JSON.parse(e.target.result);
                    socket.emit('update_pattern', pattern);
                };
                reader.readAsText(file);
            } else {
                // Parse .mid file using @tonejs/midi
                const arrayBuffer = await file.arrayBuffer();
                const midi = new Midi(arrayBuffer);
                socket.emit('update_pattern', midi.toJSON());
            }
        }

        function handleMIDIIn(event) {
            const [status, data1, data2] = event.data;
            const type = status & 0xf0;
            const channel = status & 0x0f;

            if (type === 0xb0) { // CC
                if (data1 === 74) { // Brightness/Cutoff
                    const val = (data2 / 127) * 8600 + 400; // Map 0-127 to 400-9000
                    if (leadFilter) leadFilter.frequency.rampTo(val, 0.05);
                    document.getElementById('cutoff-slider').value = val;
                }
            }

            // Basic Clock Sync (0xF8) - very simplified
            if (status === 0xf8) {
                // In a real app, we'd calculate BPM from clock pulses
                // 24 pulses per quarter note
            }
        }

        function safeTrigger(synth, note, duration) {
            try {
                const time = Tone.now() + Math.random() * 0.01 + 0.1;
                synth.triggerAttackRelease(note, duration, time);
            } catch (error) {
                console.warn('Synth trigger failed:', error);
            }
        }

        function initSocket() {
            socket = io();

            socket.on('trigger_sidechain', () => {
                
                
                triggerSidechain(Tone.now() + 0.1);
                logCode("with_fx :sidechain do");
            });

            socket.on('trigger_kick', (data) => {
                if (!audioStarted || !enabledInstruments.kick) return;
                
                const time = Tone.now() + Math.random() * 0.01 + 0.1;
                if (kickSynth) kickSynth.triggerAttackRelease("C2", "16n", time);
                sendMIDINote("C1", "16n", time, 9);
                logCode(`  sample :bd_haus, rate: 1, amp: 1`);
            });

            socket.on('trigger_bass', (data) => {
                
                
                const time = Tone.now() + Math.random() * 0.01 + 0.12;
                bassSynth.triggerAttackRelease(data.note, data.duration, time);
                sendMIDINote(data.note, data.duration, time, 1); // Channel 2
                logCode(`  play :${data.note.replace('1', '')}1, release: 0.1, synth: :prophet`);
            });

            socket.on('trigger_lead', (data) => {
                
                
                const time = Tone.now() + Math.random() * 0.01 + 0.14;

                // Harmonic Tracking (Key Follow): Base Cutoff = Note Frequency * 3
                const freq = Tone.Frequency(data.note).toFrequency();
                const baseCutoff = freq * 3;

                // Resonance Safety (Q-Limit): Lower Q as frequency increases
                const currentQ = Math.max(1, 15 - (baseCutoff / 1000));

                leadFilter.frequency.setValueAtTime(baseCutoff, time);
                leadFilter.Q.value = currentQ;

                leadSynth.triggerAttackRelease(data.note, data.duration, time);
                sendMIDINote(data.note, data.duration, time, 0); // Channel 1
                logCode(`  play :${data.note}, detune: ${data.detune.toFixed(2)}`);
            });

            socket.on('trigger_riser', (data) => {
                
                const time = Tone.now() + Math.random() * 0.01 + 0.16;
                // Ensure time is a number, though it should be already
                const scheduleTime = typeof time === 'number' ? time : Tone.now();
                // Release after duration in bars
                const durationSeconds = (60 / Tone.Transport.bpm.value) * 4 * data.duration;
                // Ensure durationSeconds is a finite number
                const finalDuration = Number.isFinite(durationSeconds) ? durationSeconds : 0.1; // Default to 0.1 if not finite
                if (noiseSynth) {
                    noiseSynth.triggerAttackRelease(finalDuration, scheduleTime);
                }
                logCode(`  sample :ambi_whitenoise, sustain: ${data.duration * 4}`);
            });

            socket.on('trigger_snare', (data) => {
                if (!audioStarted || !enabledInstruments.kick) return;
                
                const time = Tone.now() + Math.random() * 0.01 + 0.13;
                if (snareSynth) snareSynth.triggerAttackRelease("8n", time);
                logCode(`  sample :sn_dnb, amp: 0.5`);
            });

            socket.on('trigger_chords', (data) => {
                
                
                safeTrigger(chordSynth, data.notes, data.duration);
                logCode(`  play_chord [:${data.notes.join(', :')}], release: 1`);
            });

            socket.on('trigger_piano', (data) => {
                
                
                safeTrigger(pianoSynth, data.note, data.duration);
                logCode(`  play :${data.note}, synth: :piano`);
            });

            socket.on('trigger_pads', (data) => {
                
                
                safeTrigger(padSynth, data.note, data.duration);
                logCode(`  play :${data.note}, release: 4, synth: :hollow`);
            });

            socket.on('trigger_arp', (data) => {
                
                
                safeTrigger(arpSynth, data.note, data.duration);
                logCode(`  play :${data.note}, synth: :arp`);
            });

            socket.on('param_update', (data) => {
                if (data.param === 'lead_cutoff') {
                    // Clamp between 400Hz and 9000Hz
                    const clampedVal = Math.max(400, Math.min(9000, data.value));

                    // Resonance Safety applied during sweeps too
                    const currentQ = Math.max(1, 15 - (clampedVal / 1000));

                    leadFilter.frequency.linearRampToValueAtTime(clampedVal, Tone.now() + 0.05);
                    leadFilter.Q.linearRampToValueAtTime(currentQ, Tone.now() + 0.05);
                    logCode(`control :lead, cutoff: ${clampedVal.toFixed(0)}`);
                } else if (data.param === 'bass_spread') {
                    if (bassSynth && bassSynth.voices) {
                        // Use rampTime of 0.05s on all voices
                        bassSynth.voices.forEach(voice => {
                            if (voice.oscillator && voice.oscillator.spread) {
                                voice.oscillator.spread.linearRampToValueAtTime(data.value, Tone.now() + 0.05);
                            }
                        });
                    }
                }
            });

            socket.on('state_change', (data) => {
                document.getElementById('state-display').innerText = `State: ${data.state} (Bar ${data.bar})`;

                // Randomize Matrix Hue on state change
                // Groove: Green(120), Breakdown: Purple(280), Build: Orange(30), Drop: Red(0)
                if (data.state === "Groove") matrixHue = 120;
                else if (data.state === "Breakdown") matrixHue = 280;
                else if (data.state === "Build-up") matrixHue = 30;
                else if (data.state === "Drop") matrixHue = 0;

                // Nuclear Fix 3: Hard Mute Noise during Breakdown
                if (data.state === "Breakdown") {
                    if (noiseSynth) noiseSynth.volume.rampTo(-Infinity, 0.05);
                    if (snareSynth) snareSynth.volume.rampTo(-Infinity, 0.05);
                } else {
                    if (noiseSynth) noiseSynth.volume.rampTo(-20, 0.05);
                    if (snareSynth) snareSynth.volume.rampTo(-6, 0.05);
                }
                logCode(`# Transition to ${data.state.toUpperCase()}`);
            });
        }

        function setupUI() {
            document.getElementById('bpm-slider').addEventListener('input', (e) => {
                const bpm = parseFloat(e.target.value);
                Tone.Transport.bpm.value = bpm;
                document.getElementById('bpm-display').innerText = bpm;
                if (topLoopPlayer) {
                    topLoopPlayer.frequency.value = 55 * (bpm / 140);
                }
                socket.emit('set_bpm', { bpm: bpm }); // Notify backend of BPM change
                logCode(`# BPM set to ${bpm}`);
            });

            document.getElementById('save-midi-btn').addEventListener('click', () => {
                // Log recorded notes in @tonejs/midi format
                const midiData = {
                    header: { bpm: Tone.Transport.bpm.value, name: "Generative Trance" },
                    tracks: [{
                        name: "Lead",
                        notes: recordedNotes.map(n => ({
                            name: n.note,
                            time: n.time,
                            duration: n.duration,
                            velocity: 0.8
                        }))
                    }]
                };
                console.log("SAVED MIDI:", JSON.stringify(midiData, null, 2));
                logCode(`# MIDI sequence logged to console`);
            });

            document.getElementById("midi-upload").addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (file) handleMIDIPattern(file);
            });

            document.getElementById("midi-out-select").addEventListener("change", (e) => {
                if (e.target.value === "none") {
                    midiOut = null;
                } else {
                    midiOut = midiAccess.outputs.get(e.target.value);
                }
            });

            document.getElementById("midi-in-select").addEventListener("change", (e) => {
                if (midiIn) midiIn.onmidimessage = null;
                if (e.target.value === "none") {
                    midiIn = null;
                } else {
                    midiIn = midiAccess.inputs.get(e.target.value);
                    midiIn.onmidimessage = handleMIDIIn;
                }
            });

            document.getElementById('cutoff-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (leadFilter) leadFilter.frequency.linearRampToValueAtTime(val, Tone.now() + 0.1);
            });

            document.getElementById('width-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (bassSynth && bassSynth.voices) {
                    bassSynth.voices.forEach(voice => {
                        if (voice.oscillator && voice.oscillator.spread) {
                            voice.oscillator.spread.linearRampToValueAtTime(val, Tone.now() + 0.1);
                        }
                    });
                }
            });

            document.getElementById('reverb-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value) / 100;
                if (leadReverb) leadReverb.wet.linearRampToValueAtTime(val, Tone.now() + 0.1);
            });

            document.getElementById('seed-select').addEventListener('change', (e) => {
                const val = e.target.value;
                if (val === "none") {
                    socket.emit('reset_pattern');
                } else {
                    socket.emit('set_seed_pattern', { name: val });
                }
                logCode(`# Seed Pattern set to ${val.toUpperCase()}`);
            });

            document.getElementById('mutation-slider').addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                socket.emit('set_mutation', { value: val });
                logCode(`# Mutation set to ${val}%`);
            });

            document.getElementById('lfo-rate-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (leadLFO) leadLFO.frequency.linearRampToValueAtTime(val, Tone.now() + 0.1);
                logCode(`# LFO Rate set to ${val}Hz`);
            });

            document.getElementById('lfo-depth-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (leadLFO) leadLFO.amplitude.linearRampToValueAtTime(val, Tone.now() + 0.1);
                logCode(`# LFO Depth set to ${val}`);
            });

            document.getElementById('distortion-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value) / 100;
                if (leadDistortion) leadDistortion.wet.linearRampToValueAtTime(val, Tone.now() + 0.1);
                logCode(`# Lead Distortion set to ${val.toFixed(2)}`);
            });

            document.getElementById('chorus-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value) / 100;
                if (leadChorus) leadChorus.wet.linearRampToValueAtTime(val, Tone.now() + 0.1);
                logCode(`# Lead Chorus set to ${val.toFixed(2)}`);
            });

            document.getElementById('reactive-checkbox').addEventListener('change', (e) => {
                isReactive = e.target.checked;
                logCode(`# Reactive Mode ${isReactive ? 'ENABLED' : 'DISABLED'}`);
            });

            const backgroundLoopCheckbox = document.getElementById('background-loop-checkbox');
            if (topLoopPlayer) {
                topLoopPlayer.volume.mute = !backgroundLoopCheckbox.checked;
            }
            backgroundLoopCheckbox.addEventListener('change', (e) => {
                if (topLoopPlayer) {
                    topLoopPlayer.volume.mute = !e.target.checked;
                }
                logCode(`# Background Loop ${e.target.checked ? 'ENABLED' : 'DISABLED'}`);
            });

            document.getElementById('arp-mode-select').addEventListener('change', (e) => {
                const val = e.target.value;
                socket.emit('set_arp_mode', { mode: val });
                logCode(`# Arp Mode set to ${val.toUpperCase()}`);
            });

            document.getElementById('generate-ai-btn').addEventListener('click', async () => {
                const prompt = document.getElementById('ai-prompt').value;
                if (!prompt) return;
                
                logCode(`# Generating AI music: ${prompt}`);
                try {
                    const response = await fetch('/api/generate-music', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt })
                    });
                    const params = await response.json();
                    logCode(`# AI generated: BPM ${params.bpm}, Pattern ${params.melody_pattern}`);
                } catch (error) {
                    logCode('# AI generation failed');
                }
            });

            document.getElementById('reset-btn').addEventListener('click', () => {
                // Reset Sliders
                document.getElementById('cutoff-slider').value = 1000;
                document.getElementById('width-slider').value = 20;
                document.getElementById('reverb-slider').value = 30;
                document.getElementById('mutation-slider').value = 0;
                document.getElementById('lfo-rate-slider').value = 1;
                document.getElementById('lfo-depth-slider').value = 0;
                document.getElementById('distortion-slider').value = 0;
                document.getElementById('chorus-slider').value = 0;
                document.getElementById('reactive-checkbox').checked = false;
                isReactive = false;
                document.getElementById('arp-mode-select').value = "UpDown";
                document.getElementById('seed-select').value = "none";

                // Reset Audio Params
                if (leadFilter) leadFilter.frequency.linearRampToValueAtTime(1000, Tone.now() + 0.1);
                if (bassSynth && bassSynth.voices) {
                    bassSynth.voices.forEach(voice => {
                        if (voice.oscillator && voice.oscillator.spread) {
                            voice.oscillator.spread.linearRampToValueAtTime(20, Tone.now() + 0.1);
                        }
                    });
                }
                if (leadReverb) leadReverb.wet.linearRampToValueAtTime(0.3, Tone.now() + 0.1);
                if (leadLFO) {
                    leadLFO.frequency.linearRampToValueAtTime(1, Tone.now() + 0.1);
                    leadLFO.amplitude.linearRampToValueAtTime(0, Tone.now() + 0.1);
                }
                if (leadDistortion) leadDistortion.wet.linearRampToValueAtTime(0, Tone.now() + 0.1);
                if (leadChorus) leadChorus.wet.linearRampToValueAtTime(0, Tone.now() + 0.1);

                // Reset Pattern on Backend
                if (socket) socket.emit('reset_pattern');
            });

            document.getElementById('hide-ui-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                document.getElementById('ui-container').style.display = 'none';
            });

            window.addEventListener('click', () => {
                const ui = document.getElementById('ui-container');
                if (ui.style.display === 'none') {
                    ui.style.display = 'block';
                }
            });

            // Strudel-style Cycle & Trance Gate Loop
            melodyCycle = new PatternCycle([14, 18, 14, 23, 21], G_MINOR_SCALE);
            let sixteenthStep = 0;

            melodyLoop = new Tone.Loop((time) => {
                // 1. Trance Gate Logic (Applied to Bass)
                const gateValue = tranceGate.get(sixteenthStep);
                bassGate.gain.rampTo(gateValue, 0.01, time);

                // Evolve Gate every 4 bars
                if (sixteenthStep % 64 === 0 && sixteenthStep > 0) {
                    tranceGate.evolve();
                }

                // 2. Melody Cycle Logic (Strudel style)
                // Trigger every 8th note (every 2 sixteenths)
                if (sixteenthStep % 2 === 0) {
                    if (enabledInstruments.lead) {
                        const note = melodyCycle.next();
                        const duration = "16n";
                        leadSynth.triggerAttackRelease(note, duration, time);

                        recordedNotes.push({
                            note: note,
                            time: Tone.Transport.seconds,
                            duration: Tone.Time(duration).toSeconds()
                        });
                        if (recordedNotes.length > 100) recordedNotes.shift();

                        logCode(`  play :${note} # Cycle Object`);
                    }
                }

                sixteenthStep++;
            }, "16n");

            // Instrument Toggles
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const inst = btn.getAttribute('data-inst');
                    enabledInstruments[inst] = !enabledInstruments[inst];
                    btn.classList.toggle('active', enabledInstruments[inst]);

                    // Update Mute State
                    const synths = {
                        kick: [kickSynth],
                        bass: [bassSynth],
                        lead: [leadSynth],
                        chords: [chordSynth],
                        piano: [pianoSynth],
                        pads: [padSynth],
                        arp: [arpSynth]
                    };

                    if (synths[inst]) {
                        synths[inst].forEach(s => {
                            if (s) {
                                s.volume.mute = !enabledInstruments[inst];
                            }
                        });
                    }

                    logCode(`# Instrument ${inst.toUpperCase()} ${enabledInstruments[inst] ? 'ENABLED' : 'DISABLED'}`);
                });
            });

            // Mixer UI Toggle
            const mainControls = document.getElementById('controls');
            const mixerControls = document.getElementById('mixer-controls');
            const mixerToggleBtn = document.getElementById('mixer-toggle-btn');
            const backToMainControlsBtn = document.getElementById('back-to-main-controls-btn');

            mixerToggleBtn.addEventListener('click', () => {
                mainControls.style.display = 'none';
                mixerControls.style.display = 'block';
                logCode(`# Mixer UI Enabled`);
            });

            backToMainControlsBtn.addEventListener('click', () => {
                mainControls.style.display = 'block';
                mixerControls.style.display = 'none';
                logCode(`# Main Controls UI Enabled`);
            });

            // Volume Sliders for Mixer
            const volumeSliders = document.querySelectorAll('#mixer-controls input[type="range"]');
            const synthMap = {
                kick: kickSynth,
                bass: bassSynth,
                lead: leadSynth,
                chords: chordSynth,
                piano: pianoSynth,
                pads: padSynth,
                arp: arpSynth
            };

            volumeSliders.forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const inst = e.target.getAttribute('data-inst');
                    const volume = parseFloat(e.target.value);
                    if (synthMap[inst]) {
                        synthMap[inst].volume.value = volume;
                        logCode(`# ${inst.toUpperCase()} Volume: ${volume}dB`);
                    }
                });
            });
        }

        document.getElementById("start-stop-btn").addEventListener("click", async () => {
            if (!isPlaying) {
                try {
                    await Tone.start();
                    audioStarted = true;
                    console.log('Audio context started successfully');
                } catch (error) {
                    console.error('Failed to start audio context:', error);
                    return;
                }
                if (!isInitialized) {
                    setupAudio();
                    await initMIDI();
                    setupUI();
                    initSocket();
                    isInitialized = true;
                }
                socket.emit('start_music');
                isPlaying = true;
                if (topLoopPlayer) topLoopPlayer.start();
                if (melodyLoop) melodyLoop.start(0);
                Tone.Transport.start();
                document.getElementById("start-stop-btn").innerText = "STOP";
            } else {
                if (socket) socket.emit('stop_music');
                isPlaying = false;
                if (topLoopPlayer) topLoopPlayer.stop();
                if (melodyLoop) melodyLoop.stop();
                Tone.Transport.stop();
                // Add explicit silencing for all synths
                if (kickSynth) kickSynth.volume.mute = true;
                if (bassSynth) bassSynth.volume.mute = true;
                if (leadSynth) leadSynth.volume.mute = true;
                if (chordSynth) chordSynth.volume.mute = true;
                if (pianoSynth) pianoSynth.volume.mute = true;
                if (padSynth) padSynth.volume.mute = true;
                if (arpSynth) arpSynth.volume.mute = true;
                if (noiseSynth) noiseSynth.volume.mute = true;
                if (snareSynth) snareSynth.volume.mute = true;
                // Also reset effects wet to 0 to cut tails
                if (leadDelay) leadDelay.wet.value = 0;
                if (leadReverb) leadReverb.wet.value = 0;
                document.getElementById("start-stop-btn").innerText = "START";
                document.getElementById("state-display").innerText = "State: Stopped";
            }
        });

        // Hide loading overlay once all samples are loaded
        Tone.loaded().then(() => {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                overlay.style.display = 'none';
                logCode('# All samples loaded successfully');
            }
        });
    </script>
</body>
</html>
